게임 알고리즘

좌표계
 - 위치를 표현하는데 사용하는 체계
 - 데카르트 좌표계
 
좌표계 축의 방향에 따른 분류
 - 왼손좌표계 : Window 기반(DirectX)
 - 오른손좌표계 : 수학쪽, 오픈소스진영(OpenGL, 3D Max)
 
원점 기준에 따른 분류
 - 로컬 좌표계 : 자신의 원점 기준으로 한 좌표계
 - 월드 좌표계 : 월드의 원점을 기준으로 한 좌표계
 - 월드 변환(World Transform) : 오브젝트를 월드에 배치하는 작업 (위치, 회전, 스케일 적용)
 
스크린 좌표계
 - 디스플레이 기준
 - Unity는 원점을 왼쪽 아래로 삼음

랜더링 파이프라인
 - 로컬변환 -> 월드변환 -> 카메라변환 -> 투영변환(화면에 뿌리기) -> 레스터라이즈
 변환(Transform)

백터(Vector)
 - 위치와 백터는 다르다.
 - 더하기 : 각 x,y,z,를 더해서 새로운 x,y,z를 만든다.
 - 곱하기 : 벡터 * 벡터, 벡터 dot 백터
	외적(Corss Product) : 두 백터가 만드는 평면에 수직한 백터를 생성   - 	왼손으로 첫번째 백터로 손을 내밀고 
								두번째 백터로 손을 말았을때 엄지방향으로 수직함
	내적(Dot Product) : 두 백터의 사이각을 계산할 수 있다.

행렬
 - 단위행렬 : 다른 행렬에 곱해도 다른 행렬에 변화가 없는 행렬
 - 역행렬 : 어떤 행렬에 곱했을 때 단위행렬이 되는 행렬
 - transform을 표현하기 위해 사용
 - 회전을 할 때 짐벌락이 발생한다.(오일러 앵글을 사용하고 있어서)

쿼터니언
 - 오일러 앵글로 인한 짐벌락 방지 가능
 - 행렬에 비해 더 적은 메모리 차지
 - 행렬에 비해 연산 속도도 빠르다.
 
충돌 처리
 - 충돌 영역을 사용해야만 한다.(성능 문제)
 
비트연산
 - 비트끼리 계산하는 것
 - & : 둘 다 1일때만 1, 아니면 0
 - | : 둘 중 하나만 1이면 1, 아니면 0
 - << : 레프트 쉬프트 , 비트를 왼쪽으로 지정된 숫자만큼 옮기기, 한번 쉬프트 할때마다 수가 2배가 된다
	3 << 2 = 12, 0011 << 2 = 1100
 - >> : 라이트 쉬프트, 비트를 오른쪽으로 지된된 숫자만큼 옮기기, 한번 쉬프트 할때마다 나누기 2 한것과 같다.
	0011 >> 1 = 0001 
	넘치는건 없애고 빈부분은 0으로

Frustum(사각 절두체)
 - 카메라가 3D 월드에서 실제로 촬영하는 영역 (사각뿔의 형태로 이뤄짐)
  - near plane : 사각뿔에서 카메라 바로 앞 부분
  - far plane : 사각뿔에서 멀리 떨어져 있는 사각뿔의 아랫부분
 - fov : 카메라 화각
Camera
 - Position : 카메라의 위치
 - LookAt : 카메라가 바라보는곳
 - Up : 카메라의 위쪽 방향


3D 모델
 - Vertex(정점) : 점(위치)
 - Edge(간선) : 정점과 정점을 잇는 선
 - Polygon(삼각형) : 정점 3개로 만들어지는 삼각형
 - Face(면) : 삼각형이 모여서 만드는 평면
 - Mesh(메시) : 3D모델 하나(전체 외형)

보간(Interpolation) - Lerp
 - 시작값과 도착값과 전체 진행시간 중 어느 정도가 경과했는지를 알면 현재 위치를 예상하는 것

키프레임 애니메이션
 - 애니메이션의 핵심적인 동작만 저장하고 나머지는 보간을 통해 계산하는 방식



