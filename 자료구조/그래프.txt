그래프
 - 그물망 구조
 - N:M 대응

10. 그래프 : 정점과 간선으로 있다.
 정점(V) : 연결할 객체
 간선(E) : 객체를 연결하는 선

 무방향 그래프  (A,B), (B,D), (D,C)
 방향그래프 - 강력 연결그래프, 약 연결 <A,C>,<C,B>,<B,A>
 단순그래프, 멀티그래프
 완전그래프 - 최대 간선 수를 가지고 있는 그래프 정점수 * (정점수-1)/2 = N(간선의 수)
 정규 그래프 - 모든 정점이 가지고 있는 간선 개수(N)가 같은 그래프 - N차 정규 그래프
 연결그래프, 비연결 그래프
 가중치그래프 - 간선에 가중치가 되어있는 그래프 
 최소신장트리 - 가중치가 최소인 값을 구하는 알고리즘(프림, 크루스칼 알고리즘)

 정점끼리는 인접한다라는 표현
 간선은 부속된다. (A,B), (B,D), (D,C)

 차수 : 정점에서 부속되어 있는 간선 수
 경로(Path) : 정점에서 정점끼리 간선으로 연결된 정점의 집합 리스트
 단순경로 : 모두 다른 정점들로 구선된 경로
 경로길이 : 경로를 구성하는 간선의 수

 무방향그래프 표현
 V(G) = {1, 3, 5, 7, 2}, E(G) = {(3,1),(3,7),(3,7),(5,7),(7,2),(2,1)}   - 무방향이기에 (3,1)이 (1,3) 이여도 됨

 방향그래프 표현
 V(G) -= {1, 3, 7, 9, 4}, E(G) = {<1,7>,<3,7>,<9,3>,<9,7>,<4,9>,<9,4>} - 방향은 <>로 먼저 출발하는 값 뒤에 도착하는 값

 그래프 표현
 정점의 내용이 아니라 정점간에 관계, 간선의 관계를 표한하는데 목적.

 인접 행렬 방법 : N by N 정점 수 * 정점 수 만큼 배열을 만든다. - O(V^2) 메모리 필요
 연결되면 1을쓰고 아니면 0을쓴다 
 무방향 그래프는 행렬에서 대각선기준에서 대칭된 모습을 보임
 가중치를 넣는 법은 1대신 가중치 값을 적어주면 된다.
 간선의 삽입과 삭제가 편하다. - 간선이 많을수록 유리

 인접리스트 방법 : 간선으로 연결된 간선 리스트 - O(V+E)메모리 필요 -> 간선이 적은경우 유리
 연결되는 모든 정점을 리스트로 적어서 표현 무방향은 서로 전부 적어서 표현 방향성이있다면 출발하는 위치에 리스트만 적음
 가중치는 따로 옆에 적음


 그래프 탐색 방법
  - 그래프 탐색 알고리즘 (깊이 우선 탐색(DFS), 너비 우선 탐색(BFS))

 깊이 우선 탐색(DFS) - 간선 따라 최대한 중복된 정점이 나오기전까지 쭉 가고 끝까지 가면 되돌아 오면서 놓친 정점들을 체크하면서 간다 // 스택과 어울림
 너비 우선 탐색(BFS) - 주위 간선을 우선적으로 전부 탐색 중복된건 제외, 차수 순서대로 쌓임 // 큐와 어울림

 신장 트리(Spanning Tree) :	그래프를 최소 연결 시켜서 만든 트리 n개의 정점을 가지는 그래프의 최소 간선 수는 (n-1)이다. 
			DFS,BFS로 나온것이 신장트리  - 트리기 때문에 순환되면 안된다.
 최소 신장 트리(MST) : 그래프에서 모든 정점을 포함하고 간선의 가중치 합이 최소가 되는 트리 - 신장트리의 가중치의 합이 최소인것
 - prim 프림알고리즘 : 최소신장트리를 만든다. - 시작정점부터 주위 가중치가 작은것을 찾고 최소가중치를 배열에 넣고 다시 배열 주위 가중치가 작은것을 찾는다
 - 크루스칼 알고리즘 : 모든 간선들의 가중치들을 구해서 순서대로 나열한수 가장 작은 수부터 합치기 시작한다. 찾은 간선이 이미 연결되어있는 정점이 아니면 연결한다.

최단 경로 - 연결된 정점들의 리스트
 조건 - 간선 가중치 존재, 방향그래프(무방향, 양방향)
 다익스트라 알고리즘 : 특정 정점에서 정점까지의 최단 경로를 찾아준다. (음의 가중치를 적용 안함, 실생활에 적용 가능)
 벨만-포드 알고리즘 : 음의 가중치도 적용한다.

 플로이드 워샬 알고리즘 (단방향) : 모든 정점들의 쌍의 경로를 구하는

다익스트라 알고리즘

위상정렬(Toplogical Sorting)
 1. 사이클이 없는 방향성 그래프
 2. 정점들을 일렬로 정렬
 3. 진입과 진출을 따져서 정렬
 4. 정답이 여러개 존재 할 수 있다.

방법 
 1 진입차수가 0인 정점을 큐에 삽입
 2 큐에서 원소를 꺼내 정점의 간선을 제거
 3 간선 제거 이후에 진입차수가 0인 정점을 큐에 삽입
 4 큐가 빌 때까지 23번 과정을 반복한다 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재하는거고 모든 원소를 방문했다며 큐에서 꺼낸 순서가 정렬결과

 시간 복잡도, 공간 복잡도

 알고리즘의 효율성을 따지는 방법 중 하나
  시간 복잡도(Time Complexity) : 실행 시간이 어떻게 증가하는지를 설명하고 예측하는 데 사용
  공간 복잡도(Space Complexity) : 메모리를 얼마나 사용하는지

시간복잡도 표기법
 1. 빅오 표기법 (Big O : O(N))
   - 성능이 최악일 때 판단하여 평균과 가까운 성능으로 예측 (상한 예측)
 2. 빅오메가 Ω(n)
   - 성능이 최고일 때 (하한 예측) 
 3. 빅세타 Θ(n)
   - 평균적인 성능 - 빅오, 빅오메가

빠르기 순서 
O(1) - 상수시간
O(logN) - 로그 시간
O(N) - 선형시간
O(NlogN)
O(N^2)- 이차시간
O(2^N) - 지수시간
O(N^N) 
O(N!) - 계승 시간
 


